# 第3章: 让计划可见 - 添加任务规划

## 核心理念

**约束即赋能 - 待办事项让复杂任务可追踪**

v1可以处理简单任务，但面对多步骤任务时：

```
用户: "重构认证、添加测试、更新文档"
v1模型: [读取auth.py] [修改] [读取test.py] 
        [等等，我刚做了什么？] [随机跳到文档...]
```

问题是：**计划只存在于模型的"脑海"中**，不可见，不可追踪。

## TodoWrite 工具

让计划可见：

```
v2:
[ ] 重构认证模块
[>] 添加单元测试         <- 当前正在做这个
[x] 更新文档

(1/3 已完成)
```

## 关键约束

这些约束不是随意的 - 它们赋能而非限制：

| 约束 | 原因 | 效果 |
|------|------|------|
| 最多20项 | 防止无限列表 | 强制优先级排序 |
| 仅一项in_progress | 强制专注 | 一次只做一件事 |
| 必填字段 | 结构化输出 | 可解析的状态 |

**深刻洞察**：好的约束是脚手架，不是围墙。

## 代码实现要点

### 1. TodoManager 类

```typescript
class TodoManager {
  private items: TodoItem[] = [];

  update(items: TodoItem[]): string {
    // 验证
    let inProgressCount = 0;
    for (const item of items) {
      if (!item.content || !item.activeForm) {
        throw new Error('缺少必填字段');
      }
      if (item.status === 'in_progress') inProgressCount++;
    }

    // 约束
    if (items.length > 20) throw new Error('最多20项');
    if (inProgressCount > 1) throw new Error('只能一项进行中');

    this.items = items;
    return this.render();
  }

  render(): string {
    // [x] 已完成
    // [>] 进行中 <- 正在做...
    // [ ] 待处理
    // (2/3 已完成)
  }
}
```

### 2. activeForm 的价值

```typescript
{
  content: "添加测试",
  status: "in_progress",
  activeForm: "正在编写单元测试..."  // 实时可见性
}
```

渲染输出：
```
[>] 添加测试 <- 正在编写单元测试...
```

### 3. 软提醒机制

```typescript
// 对话开始时
const INITIAL_REMINDER = '<reminder>使用TodoWrite处理多步骤任务</reminder>';

// 超过10轮未使用
if (roundsWithoutTodo > 10) {
  results.unshift({ text: NAG_REMINDER });
}
```

不是强制要求，而是**温和鼓励**。

## 运行示例

```bash
$ bun run src/v2_todo_agent.ts

你：创建一个用户认证系统，包括登录、注册和密码重置

<reminder>对于多步骤任务，请使用 TodoWrite。</reminder>

我会创建用户认证系统。让我先规划一下：

> TodoWrite: {"items":[
  {"content":"创建用户模型","status":"pending","activeForm":"正在创建用户模型"},
  {"content":"实现注册接口","status":"pending","activeForm":"正在实现注册接口"},
  {"content":"实现登录接口","status":"pending","activeForm":"正在实现登录接口"},
  {"content":"添加密码重置","status":"pending","activeForm":"正在添加密码重置"},
  {"content":"编写测试","status":"pending","activeForm":"正在编写测试"}
]}

  [ ] 创建用户模型
  [ ] 实现注册接口
  [ ] 实现登录接口
  [ ] 添加密码重置
  [ ] 编写测试

(0/5 已完成)

> TodoWrite: {...}
  [>] 创建用户模型 <- 正在创建User模型...
  [ ] 实现注册接口
  [ ] 实现登录接口
  [ ] 添加密码重置
  [ ] 编写测试

(0/5 已完成)

> write_file: {"path":"src/models/User.ts",...}
  已创建 src/models/User.ts

> TodoWrite: {...}
  [x] 创建用户模型
  [>] 实现注册接口 <- 正在实现注册端点...
  [ ] 实现登录接口
  [ ] 添加密码重置
  [ ] 编写测试

(1/5 已完成)
```

## 架构图

```
┌─────────────────────────────────────────────────────────┐
│                    用户: 多步骤任务                      │
└───────────────────────┬─────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│                  模型决定使用TodoWrite                   │
└───────────────────────┬─────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│                     TodoManager.update()                 │
│  ┌─────────────────────────────────────────────────┐   │
│  │  验证: content, status, activeForm               │   │
│  │  约束: 最多20项, 仅1项in_progress                 │   │
│  └─────────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│                   render() 返回视图                      │
│  [ ] 任务 A                                              │
│  [>] 任务 B <- 正在做...                                 │
│  [x] 任务 C                                              │
│  (1/3 完成)                                              │
└─────────────────────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────┐
│          模型看到计划，更新状态，继续执行                 │
└─────────────────────────────────────────────────────────┘
```

## 关键洞察

### 1. 可见性 = 可控性

```
v1: 计划在模型"脑海"中 → 用户看不到 → 模型可能忘记
v2: 计划在对话中 → 用户可见 → 模型有参考
```

### 2. 状态管理即任务管理

```typescript
// 模型必须显式管理状态
待办事项 → in_progress → completed

// 强制模型思考：我在做什么？下一步是什么？
```

### 3. 约束的好处

```typescript
if (inProgressCount > 1) {
  throw new Error('只能一项进行中');
}
```

这看起来限制，但实际上：
- 防止多任务混乱
- 强制顺序思考
- 提供进度可见性

## 练习

1. **添加优先级**：为TodoItem添加`priority`字段，在渲染时排序

2. **添加依赖关系**：添加`dependsOn`字段，阻止在依赖完成前开始任务

3. **添加时间估算**：添加`estimatedMinutes`字段，显示总预计时间

## 对比v1

| 特性 | v1 | v2 |
|------|----|----|
| 规划 | 隐式（模型脑海） | 显式（TodoWrite） |
| 进度追踪 | ❌ | ✅ |
| 任务状态 | 不可见 | [ ] [>] [x] |
| 多步骤任务 | 容易混乱 | 有序执行 |

## 下一步

v2有了规划，但还有一个问题：**上下文污染**

```
用户: "探索整个代码库然后重构认证"
v2: [读取file1] [读取file2] ... [读取file20]
    上下文满了！模型开始忘记早期信息
```

下一章，我们将添加**子代理**来隔离上下文。
